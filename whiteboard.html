<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowBoard - Infinite Scroll</title>
    <link rel="icon" type="image/webp" href="imgs/output (8).webp">
    <style>
        /* --- CORE STYLES --- */
        :root {
            --primary: #6366f1; /* Modern Indigo */
            --primary-bg: #eef2ff;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            --border: #e5e7eb;
            --text: #1f2937;
        }

        body {
            margin: 0;
            overflow: auto; 
            background-color: #f9fafb;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            color: var(--text);
            /* Background pattern to help visualize movement */
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* --- LAYERS --- */
        #app-container {
            position: relative;
            width: 2500px; /* Infinite Scroll Area */
            height: 2000px;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            background: white;
            margin: 0;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            /* Canvas is now ABOVE text layer to allow drawing over text */
            z-index: 10; 
            touch-action: none;
        }

        #text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Text is now BELOW canvas */
            z-index: 5; 
            pointer-events: none; 
            overflow: hidden;
        }

        /* Editable Text Box */
        .text-box {
            position: absolute;
            min-width: 50px;
            min-height: 20px;
            padding: 5px 10px;
            border: 1px solid transparent;
            outline: none;
            background: transparent;
            pointer-events: auto; 
            cursor: text;
            white-space: pre-wrap;
            transition: border 0.2s;
            border-radius: 4px;
        }

        .text-box:hover { border: 1px dashed #ccc; background: rgba(255,255,255,0.5); }
        .text-box:focus { 
            border: 2px solid var(--primary); 
            background: white; 
            box-shadow: var(--shadow);
            /* Bring focused text to very top so it's editable */
            z-index: 100; 
        }

        /* --- CURSORS --- */
        /* Fixed: Hotspot set to 0 24 (Bottom Left) to match the pencil tip */
        .cursor-pen { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 22L16 8l4 4L6 26z"></path><path d="M2 22L6 26"></path><path d="M2 22l4-4"></path><path d="M14 10l4 4"></path></svg>') 0 24, auto; }
        
        .cursor-eraser { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="black" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>') 12 12, auto; }
        .cursor-crosshair { cursor: crosshair; }

        /* --- UI TOOLBARS (Fixed) --- */
        
        .top-bar {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(8px);
            padding: 8px 24px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 1000;
            border: 1px solid var(--border);
        }

        .prop-group { display: flex; align-items: center; gap: 10px; }
        .divider { width: 1px; height: 24px; background: #ddd; }

        .btn-icon {
            background: transparent; border: none; cursor: pointer; font-size: 18px; padding: 6px;
            border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #555;
        }
        .btn-icon:hover { background: #f3f4f6; color: var(--primary); }
        .btn-icon.active { background: var(--primary-bg); color: var(--primary); }

        input[type="color"] { width: 30px; height: 30px; border: none; background: none; cursor: pointer; }
        
        .toolbar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--panel-bg);
            padding: 12px;
            border-radius: 16px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
            border: 1px solid var(--border);
        }

        .tool-btn {
            width: 42px; height: 42px; border: none; background: transparent;
            border-radius: 10px; cursor: pointer; font-size: 20px; color: #666;
            transition: 0.2s;
        }
        .tool-btn:hover { background: var(--primary-bg); color: var(--primary); }
        .tool-btn.active { background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.4); }

        /* Badge & Reset Btn */
        .badge-wrap { position: relative; display: flex; flex-direction: column; align-items: center; }
        .badge { position: absolute; top: -4px; right: -4px; background: #ef4444; color: white; font-size: 10px; padding: 2px 6px; border-radius: 10px; pointer-events: none;}
        .reset-counter-btn { 
            font-size: 10px; margin-top: 2px; border: 1px solid #ddd; background: white; cursor: pointer; border-radius: 4px; padding: 1px 4px;
        }
        .reset-counter-btn:hover { background: #fee2e2; color: red; border-color: red;}

        /* Sheets */
        .sheets-bar {
            position: fixed;
            bottom: 20px; left: 20px;
            display: flex; gap: 8px; z-index: 1000;
        }
        .sheet-tab {
            background: var(--panel-bg); padding: 8px 12px 8px 16px; border-radius: 8px;
            border: 1px solid var(--border); cursor: pointer; font-weight: 500; color: #555;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex; align-items: center; gap: 8px;
        }
        .sheet-tab.active { background: var(--primary); color: white; border-color: var(--primary); }
        
        .del-sheet-btn {
            width: 16px; height: 16px; border-radius: 50%; background: rgba(0,0,0,0.1); 
            display: flex; align-items: center; justify-content: center; font-size: 10px; 
            line-height: 1; opacity: 0.6; transition: 0.2s;
        }
        .del-sheet-btn:hover { opacity: 1; background: rgba(0,0,0,0.3); color: white; }
        .sheet-tab.active .del-sheet-btn { background: rgba(255,255,255,0.3); }
        .sheet-tab.active .del-sheet-btn:hover { background: rgba(255,255,255,0.6); color: red; }

    </style>
</head>
<body>

    <div id="app-container">
        <canvas id="canvas"></canvas>
        <div id="text-layer"></div>
    </div>

    <div class="top-bar">
        <div class="prop-group">
            <input type="color" id="colorPicker" value="#000000" title="Color">
            <input type="range" id="sizeSlider" min="1" max="40" value="3" style="width: 80px" title="Size">
        </div>
        
        <div class="divider"></div>

        <div class="prop-group">
            <button class="btn-icon" id="undoBtn" title="Undo Drawing">‚Ü©</button>
            <button class="btn-icon" id="clearBtn" title="Clear Page">‚ú®</button>
            <button class="btn-icon" id="saveBtn" title="Download Image">üíæ</button>
        </div>
    </div>

    <div class="toolbar">
        <button class="tool-btn active" id="tool-pencil" title="Freehand">‚úèÔ∏è</button>
        <button class="tool-btn" id="tool-text" title="Text Box">T</button>
        
        <div class="badge-wrap">
            <button class="tool-btn" id="tool-number" title="Auto Numbering">üî¢</button>
            <div id="counterBadge" class="badge">1</div>
            <button id="resetCounterBtn" class="reset-counter-btn" title="Reset Counter">‚ü≥</button>
        </div>
        
        <div style="height: 1px; background: #eee; margin: 5px 0;"></div>
        
        <button class="tool-btn" id="tool-line" title="Line">üìè</button>
        <button class="tool-btn" id="tool-rect" title="Rectangle">‚¨ú</button>
        <button class="tool-btn" id="tool-circle" title="Circle">‚≠ï</button>
        <button class="tool-btn" id="tool-eraser" title="Eraser">üßπ</button>
    </div>

    <div class="sheets-bar" id="sheetsBar">
        <div class="sheet-tab" id="addSheetBtn" style="padding: 8px 12px;">+</div>
    </div>

    <script>
        // --- APP STATE ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const textLayer = document.getElementById('text-layer');
        const container = document.getElementById('app-container');

        const CANVAS_WIDTH = 2500;
        const CANVAS_HEIGHT = 2000;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        let app = {
            tool: 'pencil',
            painting: false,
            color: '#000000',
            size: 3,
            startX: 0, startY: 0,
            counter: 1,
            activeText: null,
            activeSheet: 1,
            sheets: {
                1: { history: [], step: -1, imgData: null } 
            }
        };

        // --- TOOL MANAGEMENT (Logic Updated for Layer Interaction) ---
        const tools = document.querySelectorAll('.tool-btn');
        
        const updateLayerInteraction = () => {
            // CRITICAL: If tool is TEXT, disable canvas interaction so clicks pass to text layer
            // If tool is DRAWING, enable canvas interaction (canvas is on top)
            if (app.tool === 'text') {
                canvas.style.pointerEvents = 'none'; // Let clicks pass to text
                canvas.className = ''; // Default cursor
            } else {
                canvas.style.pointerEvents = 'auto'; // Catch clicks on canvas
                
                // Set Cursor Style
                canvas.className = '';
                if (app.tool === 'pencil') canvas.classList.add('cursor-pen');
                else if (app.tool === 'eraser') canvas.classList.add('cursor-eraser');
                else if (['rect', 'circle', 'line', 'number'].includes(app.tool)) canvas.classList.add('cursor-crosshair');
            }
        };

        tools.forEach(btn => {
            btn.addEventListener('click', () => {
                tools.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                app.tool = btn.id.replace('tool-', '');
                
                updateLayerInteraction();

                // Deselect text if switching away
                if(app.activeText) app.activeText.blur();
            });
        });
        
        // Init cursors
        updateLayerInteraction();

        // Property Listeners
        const colorPicker = document.getElementById('colorPicker');
        const sizeSlider = document.getElementById('sizeSlider');
        
        colorPicker.addEventListener('change', (e) => {
            app.color = e.target.value;
            if(app.activeText) app.activeText.style.color = app.color;
        });
        sizeSlider.addEventListener('input', (e) => {
            app.size = e.target.value;
            if(app.activeText) app.activeText.style.fontSize = (app.size * 4 + 10) + 'px';
        });

        // --- RESET COUNTER ---
        document.getElementById('resetCounterBtn').addEventListener('click', () => {
            app.counter = 1;
            document.getElementById('counterBadge').innerText = app.counter;
        });

        // --- DRAWING ENGINE ---
        const getPos = (e) => ({ x: e.offsetX, y: e.offsetY });

        canvas.addEventListener('mousedown', (e) => {
            // If text tool is active, canvas click is disabled via CSS, 
            // but if we click empty space, we need to catch it on the container?
            // Actually, createText handles click coordinates.
            // Since canvas has pointer-events:none in Text Mode, we need listener on container or textLayer
            if (app.tool !== 'text') {
                const pos = getPos(e);
                
                app.painting = true;
                app.startX = pos.x;
                app.startY = pos.y;
                
                ctx.beginPath();
                ctx.lineWidth = app.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = app.color;
                ctx.fillStyle = app.color;
                
                app.snapshot = ctx.getImageData(0,0, canvas.width, canvas.height);

                if (app.tool === 'number') {
                    app.painting = false;
                    drawNumber(pos.x, pos.y);
                    saveState();
                } else if (app.tool === 'pencil' || app.tool === 'eraser') {
                    ctx.moveTo(pos.x, pos.y);
                }
            }
        });

        // Listen on container for Text creation because canvas ignores events in Text Mode
        container.addEventListener('mousedown', (e) => {
            if (app.tool === 'text') {
                // Ensure we aren't clicking inside an existing text box
                if (e.target.classList.contains('text-box')) return;
                // Calc correct offset relative to container
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createText(x, y);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!app.painting) return;
            const pos = getPos(e);

            if (['rect', 'circle', 'line'].includes(app.tool)) ctx.putImageData(app.snapshot, 0, 0);

            if (app.tool === 'pencil') {
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (app.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = app.size * 5;
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = app.size;
            } else if (app.tool === 'line') {
                ctx.beginPath(); ctx.moveTo(app.startX, app.startY); ctx.lineTo(pos.x, pos.y); ctx.stroke();
            } else if (app.tool === 'rect') {
                ctx.strokeRect(app.startX, app.startY, pos.x - app.startX, pos.y - app.startY);
            } else if (app.tool === 'circle') {
                ctx.beginPath();
                let r = Math.sqrt(Math.pow(pos.x - app.startX, 2) + Math.pow(pos.y - app.startY, 2));
                ctx.arc(app.startX, app.startY, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
        });

        window.addEventListener('mouseup', () => {
            if (app.painting) {
                app.painting = false;
                ctx.beginPath();
                saveState();
            }
        });

        // --- TEXT ENGINE ---
        
        function createText(x, y, content = '') {
            const div = document.createElement('div');
            div.className = 'text-box';
            div.contentEditable = true;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.color = app.color;
            div.style.fontSize = (app.size * 4 + 10) + 'px';
            div.innerText = content;
            div.dataset.sheet = app.activeSheet;

            div.addEventListener('focus', () => {
                app.activeText = div;
                colorPicker.value = rgbToHex(div.style.color);
            });

            div.addEventListener('blur', () => {
                app.activeText = null;
                if (div.innerText.trim() === '') div.remove();
            });

            textLayer.appendChild(div);
            setTimeout(() => div.focus(), 0);
        }

        function rgbToHex(col) {
            if(col.charAt(0)=='#') return col;
            let rgb = col.match(/\d+/g);
            if(!rgb) return '#000000';
            return "#" + ((1 << 24) + (parseInt(rgb[0]) << 16) + (parseInt(rgb[1]) << 8) + parseInt(rgb[2])).toString(16).slice(1);
        }

        // --- NUMBERS ---
        function drawNumber(x, y) {
            const r = 10 + parseInt(app.size);
            ctx.fillStyle = app.color;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white'; ctx.font = `bold ${r}px Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(app.counter, x, y);
            app.counter++;
            document.getElementById('counterBadge').innerText = app.counter;
        }

        // --- STATE & SAVING ---
        function saveState() {
            const sheet = app.sheets[app.activeSheet];
            // Memory Optimization
            if (sheet.history.length > 5) {
                sheet.history.shift();
                sheet.step--;
            }
            if (sheet.step < sheet.history.length - 1) {
                sheet.history = sheet.history.slice(0, sheet.step + 1);
            }
            sheet.history.push(ctx.getImageData(0,0,canvas.width,canvas.height));
            sheet.step++;
            sheet.imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
        }

        document.getElementById('undoBtn').onclick = () => {
            const sheet = app.sheets[app.activeSheet];
            if (sheet.step > 0) {
                sheet.step--;
                ctx.putImageData(sheet.history[sheet.step], 0, 0);
                sheet.imgData = sheet.history[sheet.step];
            } else {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                sheet.step = -1;
            }
        };

        document.getElementById('clearBtn').onclick = () => {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            document.querySelectorAll(`.text-box`).forEach(n => {
                if(n.dataset.sheet == app.activeSheet) n.remove();
            });
            saveState();
        };

        document.getElementById('saveBtn').onclick = () => {
            const originalData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const nodes = document.querySelectorAll('.text-box');
            
            nodes.forEach(node => {
                if(node.style.display === 'none') return;
                const style = window.getComputedStyle(node);
                const x = parseInt(style.left) + 5;
                const y = parseInt(style.top) + parseInt(style.fontSize);
                ctx.font = `${style.fontStyle} ${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
                ctx.fillStyle = style.color;
                ctx.fillText(node.innerText, x, y);
            });

            const link = document.createElement('a');
            link.download = `FlowBoard_Sheet${app.activeSheet}.png`;
            link.href = canvas.toDataURL();
            link.click();

            ctx.putImageData(originalData, 0, 0);
        };

        // --- SHEETS LOGIC ---
        const sheetsBar = document.getElementById('sheetsBar');
        const addSheetBtn = document.getElementById('addSheetBtn');

        function renderSheetTabs() {
            Array.from(sheetsBar.children).forEach(child => {
                if(child.id !== 'addSheetBtn') sheetsBar.removeChild(child);
            });

            Object.keys(app.sheets).forEach(key => {
                const id = parseInt(key);
                const btn = document.createElement('div');
                btn.className = `sheet-tab ${id === app.activeSheet ? 'active' : ''}`;
                
                const span = document.createElement('span');
                span.innerText = `Page ${id}`;
                btn.appendChild(span);

                if (id !== 1) {
                    const delBtn = document.createElement('div');
                    delBtn.className = 'del-sheet-btn';
                    delBtn.innerText = '‚úï';
                    delBtn.onclick = (e) => {
                        e.stopPropagation(); 
                        deleteSheet(id);
                    };
                    btn.appendChild(delBtn);
                }

                btn.onclick = () => switchSheet(id);
                sheetsBar.insertBefore(btn, addSheetBtn);
            });
        }
        
        function switchSheet(id) {
            if(app.sheets[app.activeSheet]) {
                app.sheets[app.activeSheet].imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
            }
            
            document.querySelectorAll(`.text-box`).forEach(el => {
                if(el.dataset.sheet == app.activeSheet) el.style.display = 'none';
            });

            app.activeSheet = id;
            
            ctx.clearRect(0,0,canvas.width,canvas.height);
            if(app.sheets[id].imgData) ctx.putImageData(app.sheets[id].imgData, 0, 0);

            document.querySelectorAll(`.text-box`).forEach(el => {
                if(el.dataset.sheet == app.activeSheet) el.style.display = 'block';
            });

            renderSheetTabs();
        }

        function deleteSheet(id) {
            if(id === 1) return; 
            
            if (confirm(`Delete Page ${id}?`)) {
                delete app.sheets[id];
                
                document.querySelectorAll(`.text-box`).forEach(el => {
                    if(el.dataset.sheet == id) el.remove();
                });

                if (app.activeSheet === id) {
                    switchSheet(1);
                } else {
                    renderSheetTabs();
                }
            }
        }

        addSheetBtn.onclick = () => {
            const ids = Object.keys(app.sheets).map(Number);
            const newId = (Math.max(...ids) || 0) + 1;
            app.sheets[newId] = { history: [], step: -1, imgData: null };
            switchSheet(newId);
        };

        renderSheetTabs();
        saveState(); 

    </script>
</body>
</html>
